<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Number em JavaScript - Guia Completo</title>
  <style>
    :root {
      --primary-color: #3498db;
      --secondary-color: #2c3e50;
      --accent-color: #e74c3c;
      --background-color: #f9f9f9;
      --code-background: #f5f5f5;
      --text-color: #333;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: var(--text-color);
      background-color: var(--background-color);
      padding: 0;
    }
    
    header {
      background-color: var(--primary-color);
      color: white;
      text-align: center;
      padding: 2rem 0;
      margin-bottom: 2rem;
    }
    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }
    
    .subtitle {
      font-size: 1.2rem;
      font-weight: 300;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 2rem 4rem;
    }
    
    section {
      margin-bottom: 3rem;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 2rem;
    }
    
    h2 {
      color: var(--secondary-color);
      margin-bottom: 1.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid var(--primary-color);
    }
    
    h3 {
      color: var(--secondary-color);
      margin: 1.5rem 0 1rem;
    }
    
    p {
      margin-bottom: 1rem;
    }
    
    code {
      font-family: 'Consolas', 'Monaco', monospace;
      background-color: var(--code-background);
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-size: 0.9rem;
    }
    
    pre {
      background-color: var(--code-background);
      padding: 1rem;
      border-radius: 5px;
      overflow-x: auto;
      margin: 1rem 0;
      border-left: 4px solid var(--primary-color);
    }
    
    pre code {
      background-color: transparent;
      padding: 0;
      font-size: 0.95rem;
    }
    
    .method-container {
      margin-bottom: 1.5rem;
    }
    
    .method-name {
      color: var(--accent-color);
      font-weight: bold;
    }
    
    .alert {
      background-color: #fff3cd;
      color: #856404;
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 5px;
      border-left: 4px solid #ffc107;
    }
    
    .danger {
      background-color: #f8d7da;
      color: #721c24;
      border-left-color: #dc3545;
    }
    
    .tip {
      background-color: #d4edda;
      color: #155724;
      border-left-color: #28a745;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }
    
    th, td {
      padding: 0.75rem;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }
    
    th {
      background-color: var(--primary-color);
      color: white;
    }
    
    tr:nth-child(even) {
      background-color: #f2f2f2;
    }
    
    .top-button {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      font-size: 1.5rem;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      transition: background-color 0.3s;
    }
    
    .top-button:hover {
      background-color: var(--secondary-color);
    }
  </style>
</head>
<body>
  <header>
    <h1>Number em JavaScript</h1>
    <p class="subtitle">Um guia completo sobre manipulação de Number em JavaScript</p>
  </header>

  <div class="container" id="container">
  </div>
  <button class="top-button" onclick="window.scrollTo({top: 0, behavior: 'smooth'})">↑</button>

  <script>
    let string = {
  tecnico: [
    { pai: "#container", filho: "introducao", tag: "section", conteudo: "" , classe:""},
    { pai: "#introducao", filho: "introducao_h2", tag: "h2", conteudo: "Introdução" },
    { pai: "#introducao", filho: "introducao_p1", tag: "p", conteudo: "Em JavaScript, o tipo <code>Number</code> é usado para representar valores numéricos, tanto inteiros quanto de ponto flutuante (decimais). Diferentemente de algumas outras linguagens, o JavaScript possui apenas um tipo numérico para todos os números." },
    { pai: "#container", filho: "representacao", tag: "section", conteudo: "" },
    { pai: "#representacao", filho: "representacao_h2", tag: "h2", conteudo: "Representação Interna (Padrão IEEE 754)" },
    { pai: "#representacao", filho: "representacao_p1", tag: "p", conteudo: "Internamente, os números em JavaScript são representados usando o formato de ponto flutuante de dupla precisão de 64 bits (IEEE 754). Isso significa que cada valor numérico é armazenado em 64 bits, divididos da seguinte forma:" },
    { pai: "#representacao", filho: "representacao_p2", tag: "p", conteudo: "Sinal (1 bit): Indica se o número é positivo (0) ou negativo (1)." },
    { pai: "#representacao", filho: "representacao_p3", tag: "p", conteudo: "Expoente (11 bits): Representa a ordem de magnitude do número (a potência de 2 pela qual a mantissa é multiplicada). O expoente é armazenado com um bias (deslocamento) de 1023." },
    { pai: "#representacao", filho: "representacao_p4", tag: "p", conteudo: "Mantissa (52 bits): Também conhecida como significando, representa os dígitos significativos do número. A mantissa é normalizada (o dígito mais significativo é sempre 1 e não é explicitamente armazenado, economizando um bit de precisão - o chamado \"bit implícito\")." },
    { pai: "#representacao", filho: "representacao_p5", tag: "p", conteudo: "Essa representação permite que o JavaScript lide com uma vasta gama de números, desde valores muito pequenos até valores muito grandes, bem como números com casas decimais." },
    { pai: "#container", filho: "limites", tag: "section", conteudo: "" },
    { pai: "#limites", filho: "limites_h2", tag: "h2", conteudo: "Limites de Precisão" },
    { pai: "#limites", filho: "limites_p1", tag: "p", conteudo: "Devido à natureza de ponto flutuante da representação IEEE 754, é importante entender que nem todos os números reais podem ser representados com precisão total. Isso pode levar a pequenas imprecisões em cálculos envolvendo números decimais." },
    { pai: "#limites", filho: "limites_pre", tag: "pre", conteudo: ``},
    { pai: "#limites_pre", filho: "limites_pre_code", tag: "code", conteudo: `
console.log(Number.MAX_SAFE_INTEGER) // (9007199254740991): Representa o maior inteiro que pode ser representado com precisão em JavaScript."
console.log(Number.MIN_SAFE_INTEGER) // (-9007199254740991 ): Representa o menor inteiro que pode ser representado com precisão em JavaScript.
    `
 },
    { pai: "#limites", filho: "limites_div", tag: "div", conteudo: "",classe:"alert" },
    { pai: "#limites_div", filho: "limites_div_h2", tag: "h3", conteudo: "CUIDADO COM OS LIMITES" },
    { pai: "#limites_div", filho: "limites_div_p", tag: "p", conteudo: "Números hexadecimais, binários e octais literais com prefixo 0x, 0b, 0o são válidos" },
    { pai: "#limites_div", filho: "limites_div_pre", tag: "pre", conteudo: "" },
    { pai: "#limites_div_pre", filho: "limites_div_pre_code", tag: "code", conteudo: `
// Números inteiros fora desse intervalo podem perder precisão.
Number.MAX_VALUE * 2 // Infinity
Number.MIN_VALUE / 2 // 0
// hexadecimais, binários e octais literais com prefixo 0x, 0b, 0o são válidos
0xff === 255
0b101 === 5
0o10 === 8

    ` },


    { pai: "#container", filho: "especiais", tag: "section", conteudo: "" },
    { pai: "#especiais", filho: "especiais_h2", tag: "h2", conteudo: "Valores Especiais" },
    { pai: "#especiais", filho: "especiais_p1", tag: "p", conteudo: "<code>NaN</code> (Not-a-Number): Representa um valor que não é um número. Geralmente resulta de operações matemáticas inválidas (por exemplo, dividir zero por zero, ou tentar converter uma string não numérica para um número).qualquer operação aritmética com <code>NaN</code> resultará em <code>NaN</code>. Detalhe é <code>Nan</code> não é igual a si mesmo (NaN === NaN é false). Para verificar se um valor é <code>NaN</code>, você deve usar a função global <code>isNaN()</code> ou, de forma mais confiável, <code>Number.isNaN()</code>." },
    { pai: "#especiais", filho: "especiais_p2", tag: "p", conteudo: "<code>Infinity</code>: Representa um valor numérico infinito positivo. Ocorre, por exemplo, ao dividir um número positivo por zero." },
    { pai: "#especiais", filho: "especiais_p3", tag: "p", conteudo: "<code>-Infinity</code>: Representa um valor numérico infinito negativo. Ocorre, por exemplo, ao dividir um número negativo por zero."},
    { pai: "#container", filho: "propriedade", tag: "section", conteudo: "" },
    { pai: "#propriedade", filho: "propriedade_h2", tag: "h2", conteudo: "Propriedades" },

    { pai: "#propriedade", filho: "especiais_p4", tag: "p", conteudo: "O objeto global <code>Number</code> possui algumas propriedades estáticas (acessadas diretamente em Number, e não em instâncias de números) que fornecem informações úteis:" },
    { pai: "#propriedade", filho: "especiais_pre", tag: "pre", conteudo: "" },
    { pai: "#especiais_pre", filho: "especiais_pre_code", tag: "code", conteudo: `
    console.log(Number.EPSILON) // 2.220446049250313e-16 A menor diferença entre 1 e o próximo maior número de ponto flutuante representável. Útil para comparações de igualdade aproximada com números de ponto flutuante.
    console.log(Number.MAX_SAFE_INTEGER) // 9007199254740991 maximo inteiro
    console.log(Number.MIN_SAFE_INTEGER) // -9007199254740991 minimo inteiro.
    console.log(Number.MAX_VALUE) // 1.7976931348623157e+308 maximo
    console.log(Number.MIN_VALUE) // 5e-324 minimo
    console.log(Number.NaN) // NaN O valor Not-a-Number.
    console.log(Number.POSITIVE_INFINITY) // Infinity O valor Infinity.
    console.log(Number.NEGATIVE_INFINITY) // -Infinity O valor -Infinity.
    ` },
    { pai: "#propriedade", filho: "propriedade_alert", tag: "div", conteudo: "", classe: "alert tip" },
    { pai: "#propriedade_alert", filho: "propriedade_alert_p", tag: "p", conteudo: ' Erros de precisão: exemplos concretos e Number.EPSILON' },
    { pai: "#propriedade_alert", filho: "propriedade_alert_pre", tag: "pre", conteudo: '' },
    { pai: "#propriedade_alert_pre", filho: "propriedade_alert_pre_code", tag: "code", conteudo: `
0.1 + 0.2 === 0.3 // false
function nearlyEqual(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
}

  ` },

  { pai: "#container", filho: "overflow", tag: "section", conteudo: "" },
  { pai: "#overflow", filho: "overflow_h2", tag: "h2", conteudo: "Overflow e Underflow silenciosos" },
  { pai: "#overflow", filho: "overflow_h3", tag: "h3", conteudo: "JavaScript não lança erro com overflow" },
  { pai: "#overflow", filho: "overflow_pre", tag: "pre", conteudo: "" },
  { pai: "#overflow_pre", filho: "overflow_pre_code", tag: "code", conteudo: `
Number.MAX_VALUE * 2 // Infinity
Number.MIN_VALUE / 2 // 0 
  ` },

    { pai: "#container", filho: "metodos", tag: "section", conteudo: "" },
    { pai: "#metodos", filho: "metodos_h2", tag: "h2", conteudo: "Metodos" },
    { pai: "#metodos", filho: "metodos_h3", tag: "h3", conteudo: "Estaticos" },
    { pai: "#metodos", filho: "metodos_h2_p", tag: "p", conteudo: "O objeto Number também possui métodos estáticos para realizar conversões e verificações relacionadas a números:" },

    { pai: "#metodos", filho: "metodos_isNaN_h3_span", tag: "span", conteudo: `Number.isNaN(value)`, classe: "method-name" },
    { pai: "#metodos", filho: "metodos_isNaN_p1", tag: "p", conteudo: `Verifica se o valor é exatamente o valor especial NaN (Not-a-Number).` },
    { pai: "#metodos", filho: "metodos_isNaN_pre", tag: "pre", conteudo: `` },
    { pai: "#metodos_isNaN_pre", filho: "metodos_isNaN_pre_code", tag: "code", conteudo: `
console.log(Number.isNaN(NaN));           // true
console.log(Number.isNaN('NaN'));         // false
console.log(Number.isNaN(undefined));     // false
    ` },
    { pai: "#metodos", filho: "metodos_alert_isNaN", tag: "div", conteudo: "", classe: "alert tip" },
    { pai: "#metodos_alert_isNaN", filho: "metodos_alert_isNaN_p", tag: "p", conteudo: 'Não faz coerção de tipo como a função global isNaN(), ou seja, é mais confiável.' },

    { pai: "#metodos", filho: "metodos_isFinite_h3_span", tag: "span", conteudo: `Number.isFinite(value)`, classe: "method-name" },
    { pai: "#metodos", filho: "metodos_isFinite_p1", tag: "p", conteudo: `Verifica se o valor é um número finito (nem Infinity, -Infinity, nem NaN).` },
    { pai: "#metodos", filho: "metodos_isFinite_pre", tag: "pre", conteudo: `` },
    { pai: "#metodos_isFinite_pre", filho: "metodos_isFinite_pre_code", tag: "code", conteudo: `
console.log(Number.isFinite(10));         // true
console.log(Number.isFinite(Infinity));   // false
console.log(Number.isFinite('10'));       // false
    ` },
    { pai: "#metodos", filho: "metodos_alert_isFinite", tag: "div", conteudo: "", classe: "alert tip" },
    { pai: "#metodos_alert_isFinite", filho: "metodos_alert_isFinite_p", tag: "p", conteudo: 'Não faz coerção de tipo, diferente da função global isFinite().' },

    { pai: "#metodos", filho: "metodos_isInteger_h3_span", tag: "span", conteudo: `Number.isInteger(value)`, classe: "method-name" },
    { pai: "#metodos", filho: "metodos_isInteger_p1", tag: "p", conteudo: `Verifica se o valor é do tipo number e é um inteiro.` },
    { pai: "#metodos", filho: "metodos_isInteger_pre", tag: "pre", conteudo: `` },
    { pai: "#metodos_isInteger_pre", filho: "metodos_isInteger_pre_code", tag: "code", conteudo: `
console.log(Number.isInteger(42));        // true
console.log(Number.isInteger(4.2));       // false
console.log(Number.isInteger('42'));      // false
    ` },

    { pai: "#metodos", filho: "metodos_isSafeInteger_h3_span", tag: "span", conteudo: `Number.isSafeInteger(value)`, classe: "method-name" },
    { pai: "#metodos", filho: "metodos_isSafeInteger_p1", tag: "p", conteudo: `Verifica se o valor é um inteiro seguro, ou seja, no intervalo entre Number.MIN_SAFE_INTEGER e Number.MAX_SAFE_INTEGER.` },
    { pai: "#metodos", filho: "metodos_isSafeInteger_pre", tag: "pre", conteudo: `` },
    { pai: "#metodos_isSafeInteger_pre", filho: "metodos_isSafeInteger_pre_code", tag: "code", conteudo: `
console.log(Number.isSafeInteger(9007199254740991));  // true
console.log(Number.isSafeInteger(9007199254740992));  // false
console.log(Number.isSafeInteger(3.14));              // false
    ` },
    { pai: "#metodos", filho: "metodos_alert_intervalor", tag: "div", conteudo: "", classe: "alert tip" },
    { pai: "#metodos_alert_intervalor", filho: "metodos_alert_intervalor_p", tag: "p", conteudo: 'Esse intervalo garante precisão exata nas operações.' },

    { pai: "#metodos", filho: "metodos_parseFloat_h3_span", tag: "span", conteudo: `Number.parseFloat(string)`, classe: "method-name" },
    { pai: "#metodos", filho: "metodos_parseFloat_p1", tag: "p", conteudo: `Analisa a string e retorna o número de ponto flutuante correspondente.` },
    { pai: "#metodos", filho: "metodos_parseFloat_pre", tag: "pre", conteudo: `` },
    { pai: "#metodos_parseFloat_pre", filho: "metodos_parseFloat_pre_code", tag: "code", conteudo: `
console.log(Number.parseFloat("3.14"));    // 3.14
console.log(Number.parseFloat("314e-2"));  // 3.14
console.log(Number.parseFloat("abc"));     // NaN
    ` },
    { pai: "#metodos", filho: "metodos_alert_parsefloat", tag: "div", conteudo: "", classe: "alert tip" },
    { pai: "#metodos_alert_parsefloat", filho: "metodos_alert_parsefloat_p", tag: "p", conteudo: 'Similar à função global parseFloat(), mas como método do objeto Number.' },

    { pai: "#metodos", filho: "metodos_parseInt_h3_span", tag: "span", conteudo: `Number.parseInt(string, radix)`, classe: "method-name" },
    { pai: "#metodos", filho: "metodos_parseInt_p1", tag: "p", conteudo: `Analisa a string e retorna um número inteiro de acordo com a base especificada.` },
    { pai: "#metodos", filho: "metodos_parseInt_pre", tag: "pre", conteudo: `` },
    { pai: "#metodos_parseInt_pre", filho: "metodos_parseInt_pre_code", tag: "code", conteudo: `
console.log(Number.parseInt("10", 10));    // 10 (decimal)
console.log(Number.parseInt("10", 2));     // 2  (binário -> decimal)
console.log(Number.parseInt("ff", 16));    // 255 (hexadecimal)
    ` },
    
    { pai: "#metodos", filho: "metodos_alert_parseint", tag: "div", conteudo: "", classe: "alert tip" },
    { pai: "#metodos_alert_parseint", filho: "metodos_alert_parseint_p", tag: "p", conteudo: 'Similar à função global parseInt(), mas como método do objeto Number.' },    

    { pai: "#metodos", filho: "instancia_h3", tag: "h3", conteudo: "Métodos de Instância" },
    { pai: "#metodos", filho: "instancia_p", tag: "p", conteudo: "As instâncias de números (variáveis que armazenam valores do tipo Number) também possuem alguns métodos para formatação" },

    { pai: "#metodos", filho: "metodos_toFixed_h3_span", tag: "span", conteudo: `toFixed(digits)`, classe: "method-name" },
    { pai: "#metodos", filho: "metodos_toFixed_p1", tag: "p", conteudo: `Formata o número para uma string com um número fixo de dígitos após o ponto decimal. Arredonda se necessário. O valor passado deve estar entre 0 e 100.` },
    { pai: "#metodos", filho: "metodos_toFixed_pre", tag: "pre", conteudo: `` },
    { pai: "#metodos_toFixed_pre", filho: "metodos_toFixed_pre_code", tag: "code", conteudo: `
let num1 = 123.456;
console.log(num1.toFixed(2));   // "123.46"
console.log(num1.toFixed(0));   // "123"
console.log((2.5).toFixed(0));  // "3" — arredonda para o inteiro mais próximo
    ` },

    { pai: "#metodos", filho: "metodos_toPrecision_h3_span", tag: "span", conteudo: `toPrecision(precision)`, classe: "method-name" },
    { pai: "#metodos", filho: "metodos_toPrecision_p1", tag: "p", conteudo: `Formata o número para uma string com um número específico de dígitos significativos. Pode usar notação exponencial se necessário. Se o número tiver mais dígitos que o especificado, ele é arredondado.` },
    { pai: "#metodos", filho: "metodos_toPrecision_pre", tag: "pre", conteudo: `` },
    { pai: "#metodos_toPrecision_pre", filho: "metodos_toPrecision_pre_code", tag: "code", conteudo: `
let num2 = 123.456;
console.log(num2.toPrecision(5));  // "123.46"
console.log(num2.toPrecision(2));  // "1.2e+2"
console.log((0.00456).toPrecision(2)); // "4.6e-3"
    ` },

    { pai: "#metodos", filho: "metodos_toString_h3_span", tag: "span", conteudo: `toString(radix)`, classe: "method-name" },
    { pai: "#metodos", filho: "metodos_toString_p1", tag: "p", conteudo: `Converte o número em uma string na base especificada (entre 2 e 36). Base 2: binário, 8: octal, 10: decimal (padrão), 16: hexadecimal.` },
    { pai: "#metodos", filho: "metodos_toString_pre", tag: "pre", conteudo: `` },
    { pai: "#metodos_toString_pre", filho: "metodos_toString_pre_code", tag: "code", conteudo: `
let num3 = 255;
console.log(num3.toString());      // "255" (decimal por padrão)
console.log(num3.toString(16));    // "ff" (hexadecimal)
console.log(num3.toString(2));     // "11111111" (binário)
    ` },

    { pai: "#metodos", filho: "metodos_toLocaleString_h3_span", tag: "span", conteudo: `toLocaleString(locales, options)`, classe: "method-name" },
    { pai: "#metodos", filho: "metodos_toLocaleString_p1", tag: "p", conteudo: `Retorna uma string formatada conforme as convenções do idioma especificado. Suporta opções para estilo numérico, moeda, uso de separador decimal etc. Muito útil para internacionalização e exibição de dados ao usuário.` },
    { pai: "#metodos", filho: "metodos_toLocaleString_pre", tag: "pre", conteudo: `` },
    { pai: "#metodos_toLocaleString_pre", filho: "metodos_toLocaleString_pre_code", tag: "code", conteudo: `
let num4 = 1234567.89;

// Exemplo com local "pt-BR" e estilo monetário:
console.log(num4.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }));
// "R$ 1.234.567,89"

// Exemplo com local "en-US" e formato decimal:
console.log(num4.toLocaleString('en-US', { minimumFractionDigits: 2 }));
// "1,234,567.89"

// Exemplo com arredondamento para 0 casas decimais:
console.log(num4.toLocaleString('de-DE', { maximumFractionDigits: 0 }));
// "1.234.568"
    ` },
    { pai: "#metodos", filho: "metodos_Coerção_h2", tag: "h2", conteudo: "Coerção" },
    { pai: "#metodos", filho: "metodos_alert_Coerção", tag: "div", conteudo: "", classe: "alert tip" },
    { pai: "#metodos_alert_Coerção", filho: "metodos_alert_Coerção_p", tag: "p", conteudo: `
JavaScript frequentemente realiza coerção de tipo envolvendo números:

Para String: Usar o operador + com uma string ou o método toString() converte um número para uma string.
Para Número: Vários operadores aritméticos (como -, *, /) e funções como Number(), parseInt(), e parseFloat() tentam converter outros tipos para números.

    ` },
    { pai: "#metodos", filho: "metodos_Coerção_pre", tag: "pre", conteudo: "" },
    { pai: "#metodos", filho: "metodos_Coerção_pre_code", tag: "code", conteudo: `
'5' - 1   // 4
'5' + 1   // '51'
true + 1  // 2
null + 1  // 1
undefined + 1 // NaN
` },

    { pai: "#metodos", filho: "metodos_Performace_h2", tag: "h2", conteudo: "Performace" },
    { pai: "#metodos", filho: "metodos_alert_Performace", tag: "div", conteudo: "", classe: "alert tip" },
    { pai: "#metodos_alert_Performace", filho: "metodos_alert_Performace_p", tag: "p", conteudo: `
As operações aritméticas com números em JavaScript geralmente são rápidas, pois são implementadas nativamente pelo motor JavaScript. No entanto, é importante estar ciente das possíveis imprecisões de ponto flutuante em cálculos complexos.
    ` }

],

    nao_tecnico:[
  { pai: "#container", filho: "introducao", tag: "section", conteudo: "", classe: "" },
  { pai: "#introducao", filho: "introducao_h2", tag: "h2", conteudo: "Introdução" },
  { pai: "#introducao", filho: "introducao_p1", tag: "p", conteudo: "Em JavaScript, o tipo <code>Number</code> é usado para representar valores numéricos, tanto inteiros quanto de ponto flutuante (decimais). Diferentemente de algumas outras linguagens, o JavaScript possui apenas um tipo numérico para todos os números." },

  { pai: "#container", filho: "representacao", tag: "section", conteudo: "" },
  { pai: "#representacao", filho: "representacao_h2", tag: "h2", conteudo: "Representação Interna (Padrão IEEE 754)" },
  { pai: "#representacao", filho: "representacao_p1", tag: "p", conteudo: "Internamente, os números em JavaScript são representados usando o formato de ponto flutuante de dupla precisão de 64 bits (IEEE 754). Isso significa que cada valor numérico é armazenado em 64 bits, divididos da seguinte forma:" },
  { pai: "#representacao", filho: "representacao_p2", tag: "p", conteudo: "Sinal (1 bit): Indica se o número é positivo (0) ou negativo (1)." },
  { pai: "#representacao", filho: "representacao_p3", tag: "p", conteudo: "Expoente (11 bits): Representa a ordem de magnitude do número (a potência de 2 pela qual a mantissa é multiplicada). O expoente é armazenado com um bias (deslocamento) de 1023." },
  { pai: "#representacao", filho: "representacao_p4", tag: "p", conteudo: "Mantissa (52 bits): Também conhecida como significando, representa os dígitos significativos do número. A mantissa é normalizada (o dígito mais significativo é sempre 1 e não é explicitamente armazenado, economizando um bit de precisão - o chamado \"bit implícito\")." },
  { pai: "#representacao", filho: "representacao_p5", tag: "p", conteudo: "Essa representação permite que o JavaScript lide com uma vasta gama de números, desde valores muito pequenos até valores muito grandes, bem como números com casas decimais." },

  { pai: "#container", filho: "limites", tag: "section", conteudo: "" },
  { pai: "#limites", filho: "limites_h2", tag: "h2", conteudo: "Limites de Precisão" },
  { pai: "#limites", filho: "limites_p1", tag: "p", conteudo: "Devido à natureza de ponto flutuante da representação IEEE 754, é importante entender que nem todos os números reais podem ser representados com precisão total. Isso pode levar a pequenas imprecisões em cálculos envolvendo números decimais." },
  { pai: "#limites", filho: "limites_pre", tag: "pre", conteudo: "" },
  {
    pai: "#limites_pre", filho: "limites_pre_code", tag: "code", conteudo: `
console.log(Number.MAX_SAFE_INTEGER) // (9007199254740991): Representa o maior inteiro que pode ser representado com precisão em JavaScript."
console.log(Number.MIN_SAFE_INTEGER) // (-9007199254740991 ): Representa o menor inteiro que pode ser representado com precisão em JavaScript.
    `
  },
  { pai: "#limites", filho: "limites_div", tag: "div", conteudo: "", classe: "alert" },
  { pai: "#limites_div", filho: "limites_div_h2", tag: "h3", conteudo: "CUIDADO COM OS LIMITES" },
  { pai: "#limites_div", filho: "limites_div_pre", tag: "pre", conteudo: "" },
  { pai: "#limites_div_pre", filho: "limites_div_pre_code", tag: "code", conteudo: "Números inteiros fora desse intervalo podem perder precisão." },

  { pai: "#container", filho: "especiais", tag: "section", conteudo: "" },
  { pai: "#especiais", filho: "especiais_h2", tag: "h2", conteudo: "Valores Especiais" },
  { pai: "#especiais", filho: "especiais_p1", tag: "p", conteudo: "<code>NaN</code> (Not-a-Number): Representa um valor que não é um número. Geralmente resulta de operações matemáticas inválidas (por exemplo, dividir zero por zero, ou tentar converter uma string não numérica para um número).qualquer operação aritmética com <code>NaN</code> resultará em <code>NaN</code>. Detalhe é <code>Nan</code> não é igual a si mesmo (NaN === NaN é false). Para verificar se um valor é <code>NaN</code>, você deve usar a função global <code>isNaN()</code> ou, de forma mais confiável, <code>Number.isNaN()</code>." },
  { pai: "#especiais", filho: "especiais_p2", tag: "p", conteudo: "<code>Infinity</code>: Representa um valor numérico infinito positivo. Ocorre, por exemplo, ao dividir um número positivo por zero." },
  { pai: "#especiais", filho: "especiais_p3", tag: "p", conteudo: "<code>-Infinity</code>: Representa um valor numérico infinito negativo. Ocorre, por exemplo, ao dividir um número negativo por zero." },

  { pai: "#container", filho: "propriedade", tag: "section", conteudo: "" },
  { pai: "#propriedade", filho: "propriedade_h2", tag: "h2", conteudo: "Propriedades" },
  { pai: "#propriedade", filho: "especiais_p4", tag: "p", conteudo: "O objeto global <code>Number</code> possui algumas propriedades estáticas (acessadas diretamente em Number, e não em instâncias de números) que fornecem informações úteis:" },
  { pai: "#propriedade", filho: "especiais_pre", tag: "pre", conteudo: "" },
  {
    pai: "#especiais_pre", filho: "especiais_pre_code", tag: "code", conteudo: `
console.log(Number.EPSILON) // 2.220446049250313e-16 A menor diferença entre 1 e o próximo maior número de ponto flutuante representável. Útil para comparações de igualdade aproximada com números de ponto flutuante.
console.log(Number.MAX_SAFE_INTEGER) // 9007199254740991 maximo inteiro
console.log(Number.MIN_SAFE_INTEGER) // -9007199254740991 minimo inteiro.
console.log(Number.MAX_VALUE) // 1.7976931348623157e+308 maximo
console.log(Number.MIN_VALUE) // 5e-324 minimo
console.log(Number.NaN) // NaN O valor Not-a-Number.
console.log(Number.POSITIVE_INFINITY) // Infinity O valor Infinity.
console.log(Number.NEGATIVE_INFINITY) // -Infinity O valor -Infinity.
    `
  },
  { pai: "#propriedade", filho: "propriedade_alert", tag: "div", conteudo: "", classe: "alert tip" },
  { pai: "#propriedade_alert", filho: "propriedade_alert_p", tag: "p", conteudo: ' Erros de precisão: exemplos concretos e Number.EPSILON' },
  { pai: "#propriedade_alert", filho: "propriedade_alert_pre", tag: "pre", conteudo: '' },
  { pai: "#propriedade_alert_pre", filho: "propriedade_alert_pre_code", tag: "code", conteudo: `
0.1 + 0.2 === 0.3 // false
function nearlyEqual(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
}

  ` },

  { pai: "#container", filho: "overflow", tag: "section", conteudo: "" },
  { pai: "#overflow", filho: "overflow_h2", tag: "h2", conteudo: "Overflow e Underflow silenciosos" },
  { pai: "#overflow", filho: "overflow_h3", tag: "h3", conteudo: "JavaScript não lança erro com overflow" },
  { pai: "#overflow", filho: "overflow_pre", tag: "pre", conteudo: "" },
  { pai: "#overflow_pre", filho: "overflow_pre_code", tag: "code", conteudo: `
Number.MAX_VALUE * 2 // Infinity
Number.MIN_VALUE / 2 // 0 
  ` },




  { pai: "#container", filho: "metodos", tag: "section", conteudo: "" },
  { pai: "#metodos", filho: "metodos_h2", tag: "h2", conteudo: "Metodos" },
  { pai: "#metodos", filho: "metodos_h3", tag: "h3", conteudo: "Estaticos" },
  { pai: "#metodos", filho: "metodos_h2_p", tag: "p", conteudo: "O objeto Number também possui métodos estáticos para realizar conversões e verificações relacionadas a números:" },

  { pai: "#metodos", filho: "metodos_isNaN_h3_span", tag: "span", conteudo: "Number.isNaN(value)",  classe: "method-name" },
  { pai: "#metodos", filho: "metodos_isNaN_p1", tag: "p", conteudo: "Verifica se o valor é exatamente o valor especial NaN (Not-a-Number)." },
  { pai: "#metodos", filho: "metodos_isNaN_pre", tag: "pre", conteudo: "" },
  {
    pai: "#metodos_isNaN_pre", filho: "metodos_isNaN_pre_code", tag: "code", conteudo: `
console.log(Number.isNaN(NaN));           // true
console.log(Number.isNaN('NaN'));         // false
console.log(Number.isNaN(undefined));     // false
    `
  },
  { pai: "#metodos", filho: "metodos_alert_isNaN", tag: "div", conteudo: "",  classe: "alert tip" },
  { pai: "#metodos_alert_isNaN", filho: "metodos_alert_isNaN_p", tag: "p", conteudo: "Não faz coerção de tipo como a função global isNaN(), ou seja, é mais confiável." },

  { pai: "#metodos", filho: "metodos_isFinite_h3_span", tag: "span", conteudo: "Number.isFinite(value)",  classe: "method-name" },
  { pai: "#metodos", filho: "metodos_isFinite_p1", tag: "p", conteudo: "Verifica se o valor é um número finito (nem Infinity, -Infinity, nem NaN)." },
  { pai: "#metodos", filho: "metodos_isFinite_pre", tag: "pre", conteudo: "" },
  {
    pai: "#metodos_isFinite_pre", filho: "metodos_isFinite_pre_code", tag: "code", conteudo: `
console.log(Number.isFinite(10));         // true
console.log(Number.isFinite(Infinity));   // false
console.log(Number.isFinite('10'));       // false
    `
  },
  { pai: "#metodos", filho: "metodos_alert_isFinite", tag: "div", conteudo: "",  classe: "alert tip" },
  { pai: "#metodos_alert_isFinite", filho: "metodos_alert_isFinite_p", tag: "p", conteudo: "Não faz coerção de tipo, diferente da função global isFinite()." },

  { pai: "#metodos", filho: "metodos_isInteger_h3_span", tag: "span", conteudo: "Number.isInteger(value)",  classe: "method-name" },
  { pai: "#metodos", filho: "metodos_isInteger_p1", tag: "p", conteudo: "Verifica se o valor é do tipo number e é um inteiro." },
  { pai: "#metodos", filho: "metodos_isInteger_pre", tag: "pre", conteudo: "" },
  {
    pai: "#metodos_isInteger_pre", filho: "metodos_isInteger_pre_code", tag: "code", conteudo: `
console.log(Number.isInteger(42));        // true
console.log(Number.isInteger(4.2));       // false
console.log(Number.isInteger('42'));      // false
    `
  },

  { pai: "#metodos", filho: "metodos_isSafeInteger_h3_span", tag: "span", conteudo: "Number.isSafeInteger(value)",  classe: "method-name" },
  { pai: "#metodos", filho: "metodos_isSafeInteger_p1", tag: "p", conteudo: "Verifica se o valor é um inteiro seguro, ou seja, no intervalo entre Number.MIN_SAFE_INTEGER e Number.MAX_SAFE_INTEGER." },
  { pai: "#metodos", filho: "metodos_isSafeInteger_pre", tag: "pre", conteudo: "" },
  {
    pai: "#metodos_isSafeInteger_pre", filho: "metodos_isSafeInteger_pre_code", tag: "code", conteudo: `
console.log(Number.isSafeInteger(9007199254740991));  // true
console.log(Number.isSafeInteger(9007199254740992));  // false
console.log(Number.isSafeInteger(3.14));              // false
    `
  },
  { pai: "#metodos", filho: "metodos_alert_intervalor", tag: "div", conteudo: "",  classe: "alert tip" },
  { pai: "#metodos_alert_intervalor", filho: "metodos_alert_intervalor_p", tag: "p", conteudo: "Esse intervalo garante precisão exata nas operações." },

  { pai: "#metodos", filho: "metodos_parseFloat_h3_span", tag: "span", conteudo: "Number.parseFloat(string)",  classe: "method-name" },
  { pai: "#metodos", filho: "metodos_parseFloat_p1", tag: "p", conteudo: "Analisa a string e retorna o número de ponto flutuante correspondente." },
  { pai: "#metodos", filho: "metodos_parseFloat_pre", tag: "pre", conteudo: "" },
  {
    pai: "#metodos_parseFloat_pre", filho: "metodos_parseFloat_pre_code", tag: "code", conteudo: `
console.log(Number.parseFloat("3.14"));    // 3.14
console.log(Number.parseFloat("314e-2"));  // 3.14
console.log(Number.parseFloat("abc"));     // NaN
    `
  },
  { pai: "#metodos", filho: "metodos_alert_parsefloat", tag: "div", conteudo: "",  classe: "alert tip" },
  { pai: "#metodos_alert_parsefloat", filho: "metodos_alert_parsefloat_p", tag: "p", conteudo: "Similar à função global parseFloat(), mas como método do objeto Number." },

  { pai: "#metodos", filho: "metodos_parseInt_h3_span", tag: "span", conteudo: "Number.parseInt(string, radix)",  classe: "method-name" },
  { pai: "#metodos", filho: "metodos_parseInt_p1", tag: "p", conteudo: "Analisa a string e retorna um número inteiro de acordo com a base especificada." },
  { pai: "#metodos", filho: "metodos_parseInt_pre", tag: "pre", conteudo: "" },
  {
    pai: "#metodos_parseInt_pre", filho: "metodos_parseInt_pre_code", tag: "code", conteudo: `
console.log(Number.parseInt("10", 10));    // 10 (decimal)
console.log(Number.parseInt("10", 2));     // 2  (binário -> decimal)
console.log(Number.parseInt("ff", 16));    // 255 (hexadecimal)
    `
  },
  { pai: "#metodos", filho: "metodos_alert_parseint", tag: "div", conteudo: "", classe: "alert tip" },
{ pai: "#metodos_alert_parseint", filho: "metodos_alert_parseint_p", tag: "p", conteudo: 'Parece com a função parseInt(), mas aqui é um jeitinho diferente dentro do objeto Number.' },    

{ pai: "#metodos", filho: "instancia_h3", tag: "h3", conteudo: "Jeitos de Usar em Variáveis" },
{ pai: "#metodos", filho: "instancia_p", tag: "p", conteudo: "Quando você guarda um número em uma variável, dá pra usar algumas funções prontas pra mostrar ele de um jeito diferente." },

{ pai: "#metodos", filho: "metodos_toFixed_h3_span", tag: "span", conteudo: `toFixed(digits)`, classe: "method-name" },
{ pai: "#metodos", filho: "metodos_toFixed_p1", tag: "p", conteudo: `Mostra o número com uma quantidade certa de casas depois da vírgula. Arredonda se precisar. Pode escolher de 0 a 100 casas.` },
{ pai: "#metodos", filho: "metodos_toFixed_pre", tag: "pre", conteudo: `` },
{ pai: "#metodos_toFixed_pre", filho: "metodos_toFixed_pre_code", tag: "code", conteudo: `
let num1 = 123.456;
console.log(num1.toFixed(2));   // "123.46"
console.log(num1.toFixed(0));   // "123"
console.log((2.5).toFixed(0));  // "3" — arredonda pra cima
` },

{ pai: "#metodos", filho: "metodos_toPrecision_h3_span", tag: "span", conteudo: `toPrecision(precision)`, classe: "method-name" },
{ pai: "#metodos", filho: "metodos_toPrecision_p1", tag: "p", conteudo: `Mostra o número com uma quantidade certa de dígitos no total. Pode até usar aquele formato com "e" se for mais prático. Arredonda quando precisa.` },
{ pai: "#metodos", filho: "metodos_toPrecision_pre", tag: "pre", conteudo: `` },
{ pai: "#metodos_toPrecision_pre", filho: "metodos_toPrecision_pre_code", tag: "code", conteudo: `
let num2 = 123.456;
console.log(num2.toPrecision(5));  // "123.46"
console.log(num2.toPrecision(2));  // "1.2e+2"
console.log((0.00456).toPrecision(2)); // "4.6e-3"
` },

{ pai: "#metodos", filho: "metodos_toString_h3_span", tag: "span", conteudo: `toString(radix)`, classe: "method-name" },
{ pai: "#metodos", filho: "metodos_toString_p1", tag: "p", conteudo: `Transforma o número em texto, podendo escolher a base: 2 (binário), 8 (octal), 10 (normal), 16 (hexadecimal) e outras até 36.` },
{ pai: "#metodos", filho: "metodos_toString_pre", tag: "pre", conteudo: `` },
{ pai: "#metodos_toString_pre", filho: "metodos_toString_pre_code", tag: "code", conteudo: `
let num3 = 255;
console.log(num3.toString());      // "255" (normal)
console.log(num3.toString(16));    // "ff" (hexadecimal)
console.log(num3.toString(2));     // "11111111" (binário)
` },

{ pai: "#metodos", filho: "metodos_toLocaleString_h3_span", tag: "span", conteudo: `toLocaleString(locales, options)`, classe: "method-name" },
{ pai: "#metodos", filho: "metodos_toLocaleString_p1", tag: "p", conteudo: `Mostra o número com o jeitinho de escrita do país escolhido. Dá pra formatar como dinheiro, ajustar vírgula, ponto, casas decimais e mais. Muito útil pra mostrar valores pro usuário.` },
{ pai: "#metodos", filho: "metodos_toLocaleString_pre", tag: "pre", conteudo: `` },
{ pai: "#metodos_toLocaleString_pre", filho: "metodos_toLocaleString_pre_code", tag: "code", conteudo: `
let num4 = 1234567.89;

// Exemplo no formato brasileiro com símbolo de real:
console.log(num4.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }));
// "R$ 1.234.567,89"

// Exemplo americano com duas casas:
console.log(num4.toLocaleString('en-US', { minimumFractionDigits: 2 }));
// "1,234,567.89"

// Exemplo alemão sem casas decimais:
console.log(num4.toLocaleString('de-DE', { maximumFractionDigits: 0 }));
// "1.234.568"
` },
{ pai: "#metodos", filho: "metodos_Coerção_h2", tag: "h2", conteudo: "Conversão Automática" },
{ pai: "#metodos", filho: "metodos_alert_Coerção", tag: "div", conteudo: "", classe: "alert tip" },
{ pai: "#metodos_alert_Coerção", filho: "metodos_alert_Coerção_p", tag: "p", conteudo: `
JavaScript costuma converter coisas automaticamente quando mistura tipos:

Pra virar texto: se usar + com uma string ou chamar toString(), ele vira texto.
Pra virar número: operadores como -, *, / ou funções como Number(), parseInt(), e parseFloat() tentam transformar o que for em número.
` },
{ pai: "#metodos", filho: "metodos_Coerção_pre", tag: "pre", conteudo: "" },
{ pai: "#metodos", filho: "metodos_Coerção_pre_code", tag: "code", conteudo: `
'5' - 1   // 4
'5' + 1   // '51'
true + 1  // 2
null + 1  // 1
undefined + 1 // NaN
` },



{ pai: "#metodos", filho: "metodos_Performace_h2", tag: "h2", conteudo: "Desempenho" },
{ pai: "#metodos", filho: "metodos_alert_Performace", tag: "div", conteudo: "", classe: "alert tip" },
{ pai: "#metodos_alert_Performace", filho: "metodos_alert_Performace_p", tag: "p", conteudo: `
Fazer contas com números no JavaScript é bem rápido, porque o navegador já sabe como lidar com isso direto. Mas, às vezes, pode ter uns errinhos de precisão, especialmente com números decimais.
` }


]

}
function validar_array(array1,campo){
  for(let valor in array1){
    for(let valor2 in array1){
      if(valor != valor2 && array1[valor][campo] == array1[valor2][campo]){
        console.log(array1[valor][campo])
      }
    }
  }
}
validar_array(string.nao_tecnico,"filho")

function criar(pai, filho, tag, conteudo = "", classe = "") {
  const el = document.createElement(tag);
  if (classe != "") {
    let classes = classe.split(" ")
    for (let i = 0; i < classes.length; i++) {
      el.classList.add(classes[i])
    }
  }
  el.id = filho;
  el.innerHTML = conteudo;
  document.querySelector(pai).appendChild(el);
}
let lista = string.tecnico
for (let i = 0; i < lista.length; i++) {
  let { pai, filho, tag, conteudo, classe } = lista[i];
  criar(pai, filho, tag, conteudo, classe);
}

  </script>
</body>
</html>